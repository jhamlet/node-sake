
var Proteus     = require("proteus"),
    EM          = require("events").EventEmitter,
    FileList    = require("sake/file-list"),
    log         = require("sake/logger"),
    defProp     = Object.defineProperty,
    defProps    = Object.defineProperties,
    isArray     = Array.isArray,
    DEFAULT_NAMESPACE = "default",
    CURRENT_NAMESPACE,
    // TBD
    FileTask,
    Task
;
//---------------------------------------------------------------------------
// Publics/Exports
//---------------------------------------------------------------------------
module.exports = Task = Proteus.Class.derive({
    //-----------------------------------------------------------------------
    // Static/Class Properties
    //-----------------------------------------------------------------------
    self: {
        
        tasks: {},
        
        initialize: function (obj, args) {
            var task = this.lookup(args[0]);
            
            if (task) {
                task.enhance(args[1], args[2]);
                this.emit("updated", task);
            }

            return task;
        },
        
        get: function (name) {
            var task, namespace, i;
            
            if (!FileTask) {
                FileTask = require("sake/file-task");
            }
            
            task = this.lookup(name) || FileTask.synthesize(name);
            
            if (!task) {
                if (~(i = name.indexOf(":"))) {
                    namespace = name.slice(0, i);
                    name = name.slice(i+1);
                }
                throw new Error("No task '" + name + "' in namespace '" + namespace + "'");
            }
            
            return task;
        },
        
        getAll: function () {
            return Object.keys(this.tasks).map(this.get, this);
        },
        
        lookup: function (name) {
            if (name instanceof this) {
                return name;
            }
            else if (typeof name === "function") {
                return this.lookup(name());
            }
            
            return this.find({name: name})[0] || null;
        },
        
        has: function (name) {
            return Boolean(this.lookup(name));
        },
        
        find: function (args, sortFn) {
            var tasks = this.tasks,
                argsIsFn = typeof args === "function",
                found, i
            ;

            // Check args if it is an object and passed a name with namespace
            // delimitier of ":"
            if (!argsIsFn) {
                if (!args.namespace && args.name &&
                    ~(i = args.name.indexOf(":"))
                ) {
                    args.namespace = args.name.slice(0, i);
                    args.name = args.name.slice(i+1);
                }
                else {
                    args.namespace = Task.namespace;
                }
            }
            
            found = Object.keys(tasks).reduce(function (t, c) {
                var task = tasks[c];
                if (task.matches(args)) {
                    t.push(task);
                }
                return t;
            }, []);
            
            if (sortFn) {
                found.sort(sortFn);
            }
            
            return found;
        },
        
        destroy: function (name) {
            delete this.tasks[name];
        },
        
        invoke: function (name, args) {
            var task = this.get(name);
            this.emit("invoking", task);
            task.invoke.apply(task, args);
        },
        
        get namespace () {
            return CURRENT_NAMESPACE || DEFAULT_NAMESPACE;
        },
        
        set namespace (name) {
            CURRENT_NAMESPACE = name;
        }
    },
    //-----------------------------------------------------------------------
    // Instance Properties
    //-----------------------------------------------------------------------
    init: function (name, prereqs, action) {
        var i, namespace;
        
        if (~(i = name.indexOf(":"))) {
            namespace = name.slice(0, 1);
            name = name.slice(i+1);
        }
        
        if (typeof prereqs === "function") {
            action = prereqs;
            prereqs = null;
        }
        
        this.name           = name;
        this.description    = "";
        this.namespace      = namespace || Task.namespace;
        this.actions        = [];

        defProps(this, {
            __pending__: {
                value: true,
                writable: true
            },
            __pendingPrereqs__: {
                value: []
            },
            __prerequisites__: {
                value: []
            },
            prerequisites: {
                get: function () {
                    this.resolve();
                    return this.__prerequisites__;
                },
                enumerable: true
            }
        });
        
        Task.tasks[this.namespace + ":" + this.name] = this;
        
        this.enhance(prereqs, action);
        
        this.enable();
    },
    
    type: "task",
    
    enhance: function (prereqs, action) {
        var isArr = isArray(prereqs),
            isFL  = prereqs instanceof FileList,
            isUndef = typeof prereqs === "undefined" || prereqs === null
        ;
        
        if (!isUndef) {
            if (!isArr && !isFL) {
                throw new Error("Prerequisites must be an Array or a FileList");
            }

            prereqs = isFL ? [prereqs] : prereqs;

            this.addPrerequisite.apply(this, prereqs);
        }
        
        if (action) {
            this.addAction(action);
        }
        
        this.emit("enhanced", this);
        
        return this;
    },
    
    invoke: function () {
        var self = this;
        
        if (!this.alreadyRun || this.isNeeded) {
            log.debug("Invoking " + this.fqn);
            this.arguments = Proteus.slice(arguments);
            require("sake/task-runner").run(this, this.complete.bind(this));
        }
        else {
            log.debug(
                this.alreadyRun ?
                    "already ran " + this.fqn :
                    this.fqn + " task is not needed"
            );
        }
        return this;
    },
    
    execute: function () {
        var self = this;
        
        this.enable();
        log.debug("Executing " + this.fqn);
        this.arguments = Proteus.slice(arguments);
        require("sake/task-runner").run(this, this.complete.bind(this));
    },
    
    done: function () {
        this.emit("actionComplete", this);
    },
    
    complete: function () {
        this.enabled = !(this.alreadyRun = true);
        log.debug(this.fqn + " completed.");
        this.emit("complete", this);
    },
    
    resolve: (function () {
        function addPending (preq) {
            Task.get(preq); // make sure the prerequisite exists as a task
            if (!~this.indexOf(preq)) {
                this.push(preq);
            }
        }
        
        return function () {
            if (this.__pending__) {
                this.__pendingPrereqs__.forEach(function (preq) {
                    if (preq instanceof FileList || isArray(preq)) {
                        preq.forEach(addPending, this);
                    }
                    else {
                        addPending.call(this, preq);
                    }
                }, this.__prerequisites__);
                this.__pendingPrereqs__.length = 0;
                this.__pending__ = false;
            }
        };
    }()),
    
    addPrerequisite: function () {
        Proteus.slice(arguments).forEach(function (preq) {
            this.push(preq);
        }, this.__pendingPrereqs__);
        this.__pending__ = true;
        return this;
    },
    
    addPrerequisites: Proteus.aliasMethod("addPrerequisite"),
    
    addAction: function () {
        Proteus.slice(arguments).forEach(function (fn) {
            if (typeof fn !== "function") {
                throw new Error("Task actuon must be a function.");
            }
            this.push(fn);
        }, this.actions);
        return this;
    },
    
    addActions: Proteus.aliasMethod("addAction"),
    
    enable: function () {
        this.alreadyRun = false;
        this.enabled = true;
        this.emit("enabled", this);
        return this;
    },
    
    destroy: function () {
        Task.destroy(this.name);
    },

    matches: function (args) {
        var key;
        
        if (typeof args === "function") {
            return args(this);
        }
        
        for (key in args) {
            if (this[key] !== args[key]) {
                return false;
            }
        }
        
        return true;
    },
    
    inspect: function () {
        return [
            Array(72).join("-"),
            "task: "            + this.name, 
            "namespace: "       + this.namespace,
            "type: "            + this.type + "-" + this.synchronicity,
            "description: "     + this.description,
            "prerequisites: "   + this.prerequisites.join(", ")
        ].join("\n");
    },
    
    toString: function () {
        return this.inspect();
    },
    
    get fqn () {
        return this.namespace + ":" + this.name;
    },
    
    get isNeeded () {
        return true;
    },
    
    get timestamp () {
        var max = Math.max.apply(
                Math,
                this.prerequisites.map(function (p) {
                    return p.timestamp;
                })
            );
        
        return isFinite(max) ? max : Date.now();
    }
    
});

// Give the Task class event emitter functionality
Proteus.extend(Task, EM.prototype);
// And the same for the instances of Task
Task.include(EM);
