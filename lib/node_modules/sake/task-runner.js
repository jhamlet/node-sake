
var Proteus = require("proteus"),
    async   = require("async"),
    Task    = require("sake/task"),
    options = require("sake/options"),
    log     = require("sake/logger"),
    Runner,
    ActionRunner,
    TaskRunner,
    TaskQueue
;

/**
 * Base class for Task and Actions runners
 */
Runner = Proteus.Class.derive({
    init: function (callback) {
        this.callback = callback;
    },
    
    run: function () {
        this.postRun();
    },
    
    postRun: function () {
        this.complete();
    },
    
    complete: function () {
        var nil = this.callback && this.callback();
        this.destroy();
    },
    
    destroy: function () {
        delete this.callback;
    }
});

/**
 * Responsible for running a tasks actions, one by one.
 */
ActionRunner = Runner.derive({
    
    init: function (task, callback) {
        this.task = task;
        ActionRunner.__super__.init.call(this, callback);
    },
    
    run: function () {
        var task        = this.task,
            actions     = task.actions,
            noActions   = !actions || !actions.length,
            callback    = ActionRunner.__super__.run.bind(this)
        ;
        
        if (noActions) {
            log.debug("No actions for " + task.fqn);
            callback();
            return;
        }
        
        async.series(actions.map(this.makeAsyncCallback, this), callback);
    },
    
    destroy: function () {
        delete this.task;
        ActionRunner.__super__.destroy.call(this);
    },
    
    makeAsyncCallback: function (action, idx) {
        var self = this,
            task = this.task,
            isDryRun    = options.dryrun,
            dryRunSfx   = isDryRun ? " (dry-run)" : ""
        ;

        return function (asyncCb) {
            var nil;
            
            function actionCb () {
                log.debug("Action " + idx + " complete" + dryRunSfx);
                task.removeListener("actionComplete", actionCb);
                asyncCb();
            }
            
            task.on("actionComplete", actionCb);
            log.debug("Execute action " + idx + dryRunSfx);
            
            nil = isDryRun ? 
                task.done() :
                action.apply(task, [task].concat(task.arguments));
            
        };
    },
});

/**
 * Responsible for executing a task
 */
TaskRunner = Runner.derive({
    
    init: function (task, callback) {
        this.task = task;
        TaskRunner.__super__.init.call(this, callback);
    },
    
    run: function () {
        var task        = this.task,
            callback    = TaskRunner.__super__.run.bind(this),
            alreadyRun  = task.alreadyRun,
            isNeeded    = task.isNeeded,
            actionRunner
        ;
        
        if (task.isRunning) {
            log.debug(task.fqn + " already running.");
            return;
        }
        
        if (alreadyRun || !isNeeded) {
            log.debug(task.fqn + (alreadyRun ? " already ran." : " is not needed."))
            callback();
            return;
        }
        
        task.isRunning = true;
        
        log.debug("Running " + task.fqn);
        actionRunner = this.actionRunner = new ActionRunner(task, callback);
        actionRunner.run();
    },
    
    destroy: function () {
        delete this.task.isRunning;
        delete this.actionRunner;
        TaskRunner.__super__.destroy.call(this);
    }
    
});

TaskQueue = Runner.derive({
    
    init: function (taskchain, callback) {
        this.chain = taskchain;
        TaskQueue.__super__.init.call(this, callback);
    },
    
    run: function () {
        this.taskRunner = (new TaskRunner(
            this.chain.pop(), 
            TaskQueue.__super__.run.bind(this)
        )).run();
    },
    
    postRun: function () {
        if (this.chain.length > 0) {
            this.run();
        }
        else {
            this.complete();
        }
    },
    
    destroy: function () {
        delete this.chain;
        delete this.taskRunner;
        TaskQueue.__super__.destroy.call(this);
    }
});

module.exports = {
    // Add a task
    // Is the name of tha task alreay in the list?
    //      yes: Possible Recursion - are any of its prerequisites in the list?
    //              yes: Are any of that prerequisites prerequisites in the list
    //                  yes: blow up
    //              no:  Move the task name to the end of the list
    // Process prerequisites
    getTaskNameChain: function (task, taskchain) {
        var taskname, i, prereqs, preqlist;

        taskchain = taskchain || [];
        taskname  = task.fqn;
        prereqs   = task.prerequisites;

        if (~(i = taskchain.indexOf(taskname))) {
            // possible recurion...
            if (prereqs.some(function (name) {
                    // check the prequisites
                    var t = Task.get(name);
                    if (~taskchain.indexOf(t.fqn) && 
                        t.prerequisites.some(function (pname) {
                            // and the prerequisites' prerequisites
                            return Boolean(~taskchain.indexOf(Task.get(pname).fqn));
                        })
                    ) {
                        return true;
                    }
                    return false;
                })
            ) {
                throw "Recursive dependency detected: " +
                    taskchain.concat(task.fqn).map(function (name) {
                        return "\"" + name + "\"";
                    }).join(", ");
            }
            // else, remove it from its place in front of the list
            taskchain.splice(i, 1);
        }
        // push it onto the back
        taskchain.push(taskname);
        task.prerequisites.forEach(function (name) {
            this.getTaskNameChain(Task.get(name), taskchain);
        }, this);

        return taskchain;
    },
    
    run: function (task, callback) {
        var chain;
        
        try {
            chain = this.getTaskNameChain(task);
        }
        catch (e) {
            log.error(e);
            process.exit(0);
        }

        log.debug("Task chain: " + chain.join(", "));

        (new TaskQueue(chain.map(function (name) {
            return Task.get(name);
        }), callback)).run();
        
    }
};
