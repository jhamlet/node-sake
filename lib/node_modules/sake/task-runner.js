
var Proteus = require("proteus"),
    async   = require("async"),
    Task    = require("sake/task"),
    options = require("sake/options"),
    log     = require("sake/logger"),
    Runner,
    ActionRunner,
    TaskRunner
;

/**
 * Base class for Task and Actions runners
 */
Runner = Proteus.Class.derive({
    init: function (callback) {
        this.callback = callback;
    },
    
    run: function () {
        this.postRun();
    },
    
    postRun: function () {
        this.complete();
    },
    
    complete: function () {
        var nil = this.callback && this.callback();
        this.destroy();
    },
    
    destroy: function () {
        delete this.callback;
    }
});

/**
 * Responsible for running a tasks actions, one by one.
 */
ActionRunner = Runner.derive({
    
    init: function (task, callback) {
        this.task = task;
        ActionRunner.__super__.init.call(this, callback);
    },
    
    run: function () {
        var task        = this.task,
            actions     = task.actions,
            noActions   = !actions || !actions.length,
            callback    = ActionRunner.__super__.run.bind(this)
        ;
        
        if (noActions) {
            log.debug("No actions for " + task.fqn);
            callback();
            return;
        }
        
        async.series(actions.map(this.makeAsyncCallback, this), callback);
    },
    
    destroy: function () {
        delete this.task;
        ActionRunner.__super__.destroy.call(this);
    },
    
    makeAsyncCallback: function (action, idx) {
        var self = this,
            task = this.task,
            isDryRun    = options.dryrun,
            dryRunSfx   = isDryRun ? " (dry-run)" : ""
        ;

        return function (asyncCb) {
            var nil;
            
            function actionCb () {
                log.debug(task.fqn + " action " + idx + " complete" + dryRunSfx);
                task.removeListener("actionComplete", actionCb);
                asyncCb();
            }
            
            task.on("actionComplete", actionCb);
            log.debug("Execute " + task.fqn + " action " + idx + dryRunSfx);
            
            nil = isDryRun ? 
                task.done() :
                action.apply(task, [task].concat(task.arguments));
            
        };
    },
});

/**
 * Responsible for executing a task's prerequisites one by one
 */
TaskRunner = Runner.derive({
    
    init: function (task, callback) {
        this.task = task;
        TaskRunner.__super__.init.call(this, callback);
    },
    
    run: function () {
        var task        = this.task,
            running     = task.isRunning,
            prereqs     = task.prerequisites,
            hasPreqs    = prereqs && prereqs.length,
            callback    = TaskRunner.__super__.run.bind(this)
        ;
        
        if (running) {
            log.warn(
                "Possible dependency recursion: " + task.fqn +
                " is already running."
            );
            return;
        }
        
        if (!hasPreqs) {
            log.debug("No prerequisites for " + task.fqn);
            return callback();
        }
        
        task.isRunning = true;
        async.series(prereqs.map(this.makeAsyncCallback, this), callback);
    },
    
    postRun: function () {
        (this.actionRunner = new ActionRunner(
            this.task,
            TaskRunner.__super__.postRun.bind(this)
        )).run();
    },
    
    makeAsyncCallback: function (taskname) {
        var self = this,
            task = Task.get(taskname, self.task.namespace)
        ;
        
        return function (asyncCb) {
            function taskCb () {
                task.removeListener("complete", taskCb);
                asyncCb();
            }
            
            task.on("complete", taskCb);
            task.invoke();
        };
    },
    
    destroy: function () {
        delete this.task.isRunning;
        delete this.actionRunner;
        TaskRunner.__super__.destroy.call(this);
    }
    
});

module.exports = {
    run: function (task, callback) {
        (new TaskRunner(task, callback)).run();
    }
};
