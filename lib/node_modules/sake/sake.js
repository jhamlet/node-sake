
var Proteus         = require("proteus"),
    resolve         = require("resolve"),
    VM              = require("vm"),
    FS              = require("fs"),
    Path            = require("path"),
    nutil           = require("util"),
    Glob            = require("glob"),
    sutil           = require("sake/util"),
    log             = require("sake/logger"),
    nodeRequire     = require,
    nodePath        = process.env.NODE_PATH,
    nodePaths       = nodePath ? nodePath.split(":") : [],
    taskDescription = "",
    sake            = {},
    OPTIONS         = {},
    INCLUDE_PATHS   = [],
    NAMESPACES      = [],
    CURRENT_PATH,
    sakeContext,
    futil,
    Task,
    FileTask,
    FileList,
    FileCreateTask
;
//---------------------------------------------------------------------------
// Utility for resolving requires
//---------------------------------------------------------------------------
INCLUDE_PATHS.push(__dirname, process.cwd());
CURRENT_PATH = INCLUDE_PATHS[INCLUDE_PATHS-1];

function sakeRequire (name) {
    try {
        return nodeRequire(name);
    }
    catch (e) {
        return nodeRequire(resolve.sync(name, {
            basedir: Path.dirname(CURRENT_PATH),
            paths: nodePaths.concat(INCLUDE_PATHS)
        }));
    }
}
//---------------------------------------------------------------------------
// Create the Run Context
//---------------------------------------------------------------------------
function getRunContext () {
    if (!sakeContext) {
        sakeContext = VM.createContext(
            Proteus.merge(
                {
                    console:        console,
                    process:        process,
                    
                    Buffer:         Buffer,
                    setTimeout:     setTimeout,
                    setInterval:    setInterval,
                    clearTimeout:   clearTimeout,
                    clearInterval:  clearInterval
                },
                sake,
                futil
            )
        );
    }
    
    return sakeContext;
}
//---------------------------------------------------------------------------
// Privates
//---------------------------------------------------------------------------
function defineTask (TaskClass, sync, name, prereqs, action) {
    var task;
    
    if (!action && typeof prereqs === "function") {
        action = prereqs;
        prereqs = null;
    }
    
    task = sync ? 
        new TaskClass(name, prereqs, function (t) {
            var v = action && action(t);
            t.done();
        }) :
        new TaskClass(name, prereqs, action);
    
    task.description = taskDescription;
    taskDescription = "";
    
    if (!sync && action &&
        (action.length < 1 || !(/\.(done|abort)\(/.test(action.toString())))
    ) {
        log.warn(
            "Possibly missing task callback in asynchronous action " +
            "added to task '" + task.fqn + "'"
        );
    }
    
    return task;
}

function createTask (TaskClass, name, prereqs, action) {
    return defineTask(
        TaskClass,
        sake.options.sync,
        name,
        prereqs,
        action
    );
}
//---------------------------------------------------------------------------
// Public/Exports
//---------------------------------------------------------------------------
Proteus.merge(sake, Object.defineProperties({
    
    run: function (filepath) {
        var tmpPath = CURRENT_PATH,
            isFn, code, ret
        ;
        
        if (typeof filepath === "function") {
            isFn = true;
            code = "(" + filepath.toString() + "())";
            filepath = "anonymous function";
        }
        else {
            filepath = Path.resolve(sake.__dirname, filepath);
            CURRENT_PATH = filepath;

            code = FS.readFileSync(filepath, "utf8");
            
            if (Path.extname(filepath).toLowerCase() === ".coffee") {
                try {
                    code = require("coffee-script").compile(code);
                }
                catch (e) {
                    process.stderr.write("Coffee script is not installed.\n");
                    process.exit(1);
                }
            }
        }
        
        try {
            ret = VM.runInContext(code, getRunContext(), filepath);
        }
        catch (runErr) {
            // TODO: Define a Sake specific error
            process.stderr.write(
                filepath + ": " +  runErr.toString() + runErr.stack + "\n"
            );
            process.exit(1);
        }
        
        if (!isFn) {
            CURRENT_PATH = tmpPath;
        }
        
        return ret;
    },
    
    load:    Proteus.aliasMethod("run", sake),
    include: Proteus.aliasMethod("run", sake),
    
    require: sakeRequire,
    
    log: require("sake/logger"),
    
    description: function (txt) {
        taskDescription += txt;
    },
    desc: Proteus.aliasMethod("description", sake),
    
    directory: (function () {
        
        function mkdirAction (t) {
            if (!Path.existsSync(t.name)) {
                futil.mkdir_p(t.name);
            }
        }

        return function (name) {
            var dirpath = name;

            while (dirpath !== "." && dirpath !== "/") {
                sake.fileCreateSync(dirpath, mkdirAction);
                dirpath = Path.dirname(dirpath);
            }

            return Task.get(name);
        };
    }()),
    
    namespace: function (name, fn) {
        var prev = Task.namespace;
        
        if (!arguments.length) {
            return prev;
        }
        
        Task.namespace = name;
        
        fn();
        
        Task.namespace = prev;
    },
    
    includePaths: INCLUDE_PATHS,
    
    sake: sake,
    
    async: require("async")
}, {
    __dirname: {
        get: function () {
            return Path.dirname(CURRENT_PATH);
        },
        enumerable: true
    },
    
    __filename: {
        get: function () {
            return CURRENT_PATH;
        },
        enumerable: true
    }
}));
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
/**
 * Define the exports as a 'getter', and then re-define it as a plain property
 * once everything is all setup and ready to go.
 */
Object.defineProperty(module, "exports", {
    get: function () {
        var opts = (sake.options = require("sake/options"));

        opts.requires.forEach(function (name) {
            var property = sutil.toCamelCase(Path.basename(name, ".js"));
            if (!sake.hasOwnProperty(property)) {
                sake[property] = sakeRequire(name);
            }
            else {
                throw new Error(
                    "Namespace conflict. Can not require '" + name + "'" +
                    "as it will conflict with a property that is " +
                    "already defined."
                );
            }
        });
        
        // Re-define our exported property
        Object.defineProperty(module, "exports", {
            value: sake,
            enumerable: true
        });
        
        // Require these here to avoid recursive requires
        futil                                   = require("sake/file-utils");
        sake.Task           = Task              = require("sake/task");
        sake.FileTask       = FileTask          = require("sake/file-task");
        sake.FileCreateTask = FileCreateTask    = require("sake/file-create-task");
        sake.FileList       = FileList          = require("sake/file-list");
        
        // bind our task creation functions
        sake.task       = createTask.bind(sake, Task);
        sake.taskAsync  = defineTask.bind(sake, Task, false);
        sake.taskSync   = defineTask.bind(sake, Task, true);
        
        sake.file       = createTask.bind(sake, FileTask);
        sake.fileAsync  = defineTask.bind(sake, FileTask, false);
        sake.fileSync   = defineTask.bind(sake, FileTask, true);
        
        sake.fileCreate         = createTask.bind(sake, FileCreateTask);
        sake.fileCreateAsync    = defineTask.bind(sake, FileCreateTask, false);
        sake.fileCreateSync     = defineTask.bind(sake, FileCreateTask, true);
        
        // load sakelib files
        opts.sakelib.filter(function (dirpath, idx) {
            return Path.existsSync(dirpath) &&
                    FS.statSync(dirpath).isDirectory();
        }).reduce(function (paths, dirpath) {
            var glob = Path.join(dirpath, "*.{sake,sake.js,sake.coffee}");
            return paths.concat(Glob.sync(glob));
        }, []).forEach(sake.load, sake);
        
        // return our object
        return sake;
    },
    enumerable: true,
    configurable: true
});

