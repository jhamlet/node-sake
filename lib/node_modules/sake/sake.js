
var Proteus         = require("proteus"),
    resolve         = require("resolve"),
    VM              = require("vm"),
    FS              = require("fs"),
    Path            = require("path"),
    nutil           = require("util"),
    sutil           = require("sake/util"),
    log             = require("sake/logger"),
    nodeRequire     = require,
    nodePath        = process.env.NODE_PATH,
    nodePaths       = nodePath ? nodePath.split(":") : [],
    taskDescription = "",
    sake            = {},
    OPTIONS         = {},
    INCLUDE_PATHS   = [],
    NAMESPACES      = [],
    sakeContext,
    futil,
    Task,
    FileTask,
    FileList,
    FileCreateTask
;
//---------------------------------------------------------------------------
// Utility for resolving requires
//---------------------------------------------------------------------------
INCLUDE_PATHS.push(__dirname, process.cwd());
function sakeRequire (name) {
    try {
        return nodeRequire(name);
    }
    catch (e) {
        return nodeRequire(resolve.sync(name, {
            basedir: INCLUDE_PATHS[INCLUDE_PATHS.length-1],
            paths: nodePaths.concat(INCLUDE_PATHS.slice(0, INCLUDE_PATHS.length))
        }));
    }
}
//---------------------------------------------------------------------------
// Create the Run Context
//---------------------------------------------------------------------------
function getRunContext () {
    if (!sakeContext) {
        sakeContext = VM.createContext(
            Proteus.merge(
                {
                    console: console,
                    require: sakeRequire,
                    process: process
                },
                sake,
                futil
            )
        );
    }
    
    return sakeContext;
}
//---------------------------------------------------------------------------
// Privates
//---------------------------------------------------------------------------
function defineTask (TaskClass, sync, name, prereqs, action) {
    var task;
    
    if (!action && typeof prereqs === "function") {
        action = prereqs;
        prereqs = null;
    }
    
    task = sync ? 
        new TaskClass(name, prereqs, function (t) {
            var v = action && action(t);
            t.done();
        }) :
        new TaskClass(name, prereqs, action);
    
    task.description = taskDescription;
    taskDescription = "";
    
    if (!sync && action &&
        (action.length < 1 || (!/\.done\(\)/.test(action.toString())))
    ) {
        log.warn(
            "Possibly missing 'done' callback in asynchronous action " +
            "added to task '" + task.fqn + "'"
        );
    }
    
    return task;
}

function createTask (TaskClass, name, prereqs, action) {
    return defineTask(
        TaskClass,
        sake.options.synchronous,
        name,
        prereqs,
        action
    );
}
//---------------------------------------------------------------------------
// Public/Exports
//---------------------------------------------------------------------------
Proteus.merge(sake, {
    
    run: function (filepath) {
        var curPath = INCLUDE_PATHS[INCLUDE_PATHS.length-1],
            isFn, code, ret
        ;
        
        if (typeof filepath === "function") {
            isFn = true;
            code = "(" + filepath.toString() + "())";
            filepath = "anonymous function";
        }
        else {
            filepath = Path.resolve(curPath, filepath);
            INCLUDE_PATHS.push(Path.dirname(filepath));

            code = FS.readFileSync(filepath, "utf8");
            
            if (Path.extname(filepath).toLowerCase() === ".coffee") {
                try {
                    code = require("coffee-script").compile(code);
                }
                catch (e) {
                    process.stderr.write("Coffee script is not installed.\n");
                    process.exit(1);
                }
            }
        }
        
        try {
            ret = VM.runInContext(code, getRunContext(), filepath);
        }
        catch (runErr) {
            // TODO: Define a Sake specific error
            process.stderr.write(
                filepath + ": " +  runErr.toString() + runErr.stack + "\n"
            );
            process.exit(1);
        }
        
        if (!isFn) {
            INCLUDE_PATHS.pop();
        }
        
        return ret;
    },
    
    load:    Proteus.aliasMethod("run", sake),
    include: Proteus.aliasMethod("run", sake),
    
    log: require("sake/logger"),
    
    description: function (txt) {
        taskDescription += txt;
    },
    desc: Proteus.aliasMethod("description", sake),
    
    directory: (function () {
        
        function mkdirAction (t) {
            if (!Path.existsSync(t.name)) {
                futil.mkdir_p(t.name);
            }
        }

        return function (name) {
            var dirpath = name;

            while (dirpath !== "." && dirpath !== "/") {
                sake.fileCreateSync(dirpath, mkdirAction);
                dirpath = Path.dirname(dirpath);
            }

            return Task.get(name);
        };
    }()),
    
    namespace: function (name, fn) {
        var prevNS = Task.namespace;
        
        if (!arguments.length) {
            return prevNS;
        }
        
        Task.namespace = name;
        
        fn();
        
        Task.namespace = prevNS;
    },
    
    sake: sake,
    
    async: require("async")
});
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
/**
 * Define the exports as a 'getter', and then re-define it as a plain property
 * once everything is all setup and ready to go.
 */
Object.defineProperty(module, "exports", {
    get: function () {
        var opts        = (sake.options = require("sake/options"));

        opts.requires.forEach(function (name) {
            var property = sutil.toCamelCase(Path.basename(name, ".js"));
            if (!sake.hasOwnProperty(property)) {
                sake[property] = sakeRequire(name);
            }
            else {
                throw new Error(
                    "Namespace conflict. Can not require '" + name + "'" +
                    "as it will conflict with a property that is " +
                    "already defined."
                );
            }
        });
        
        // Re-define our exported property
        Object.defineProperty(module, "exports", {
            value: sake,
            enumerable: true
        });
        
        // Require these here to avoid recursive requires
        futil                                   = require("sake/file-utils");
        sake.Task           = Task              = require("sake/task");
        sake.FileTask       = FileTask          = require("sake/file-task");
        sake.FileCreateTask = FileCreateTask    = require("sake/file-create-task");
        sake.FileList       = FileList          = require("sake/file-list");
        
        // bind our task creation functions
        sake.task       = createTask.bind(sake, Task);
        sake.taskAsync  = defineTask.bind(sake, Task, false);
        sake.taskSync   = defineTask.bind(sake, Task, true);
        
        sake.file       = createTask.bind(sake, FileTask);
        sake.fileAsync  = defineTask.bind(sake, FileTask, false);
        sake.fileSync   = defineTask.bind(sake, FileTask, true);
        
        sake.fileCreate         = createTask.bind(sake, FileCreateTask);
        sake.fileCreateAsync    = defineTask.bind(sake, FileCreateTask, false);
        sake.fileCreateSync     = defineTask.bind(sake, FileCreateTask, true);
        
        // return our object
        return sake;
    },
    enumerable: true,
    configurable: true
});

