
var Proteus = require("proteus"),
    FS      = require("fs"),
    Path    = require("path"),
    nutil   = require("util"),
    sutil   = require("sake/util"),
    Task    = require("sake/task"),
    log     = require("sake/logger"),
    DEFAULT_SAKEFILES = [
        "Sakefile", "sakefile", "Sakefile.js", "sakefile.js",
        "Sakefile.coffee", "sakefile.coffee",
    ]
;

module.exports = {
    
    run: function () {
        var opts     = this.options,
            cmd      = opts._[0],
            taskArgs = opts._.slice(1).map(sutil.jsonToValue),
            task
        ;
        
        this.loadSakefile(opts.sakefile);
        
        this.processRunOptions();
        
        Task.invoke.apply(Task, [opts.taskName].concat(taskArgs));
    },
    
    processRunOptions: function () {
        var opts = this.options,
            pattern = opts._[0],
            exit = false;
        
        if (opts.listTasks) {
            this.listTasks(pattern);
            exit = true;
        }
        else if (opts.listPrereqs) {
            this.listTasksAndPrerequisites(pattern);
            exit = true;
        }
        
        if (exit) {
            process.exit(0);
        }
    },
    
    loadSakefile: function (filepath) {
        var dir;
        
        filepath = filepath || this.sakefileLocation();

        if (!Path.existsSync(filepath)) {
            throw new Error("Can not find a Sakefile.");
        }

        filepath = Path.resolve(filepath);
        this.options.sakefile = filepath;
        
        dir = Path.dirname(filepath);
        process.chdir(dir);
        
        log.info("sake in " + dir);

        (this.sake = require("sake")).load(filepath);
    },
    
    sakefileLocation: function () {
        var here = process.cwd(),
            start = here,
            filename
        ;
            
        while (!(filename = this.haveSakefile(here)) && here !== "/") {
            process.chdir("..");
            here = process.cwd();
        }
        
        process.chdir(start);
        
        if (filename) {
            return Path.join(here, filename);
        }
    },
    
    haveSakefile: function (here) {
        var filenames = FS.readdirSync(here),
            len = filenames.length,
            i = 0,
            f
        ;
        
        for (; i < len; i++) {
            f = filenames[i];
            if (~DEFAULT_SAKEFILES.indexOf(f)) {
                return f;
            }
        }
    },
    
    listTasks: function (pattern) {
        var nameW = 0;
        
        log("Tasks:");
        
        pattern = pattern && new RegExp(pattern);
        
        Task.getAll().filter(function (task) {
            return task.description && (!pattern || pattern.test(task.fqn));
        }).map(function (task) {
            var name = task.fqn, len  = name.length;
            nameW = len > nameW ? len : nameW;
            return task;
        }).forEach(function (t) {
            var name = t.fqn, len  = name.length;
            
            log("  " + name + Array(nameW - len + 5).join(" ") + "# " +
                t.description);
        });
    },
    
    listTasksAndPrerequisites: (function () {
        
        function formatTask (task, pad) {
            return (pad ? pad : "") + task.fqn + " (" + task.type + ")";
        }
        
        return function (pattern) {
            log("Tasks and Prerequisites: ");
            
            pattern = pattern && new RegExp(pattern);
            
            Task.getAll().filter(function (task) {
                return !pattern || pattern.test(task.fqn);
            }).forEach(function (task) {
                var preqs       = task.prerequisites,
                    pad         = "  "
                ;

                log(formatTask(task, pad));
                preqs.forEach(function (name) {
                    log(formatTask(Task.lookup(name, task.namespace), pad + pad));
                });
            });
        };
    }()),
    
    get options () {
        return require("sake/options");
    }
};
