
var Proteus     = require("proteus"),
    EM          = require("events").EventEmitter,
    FileList    = require("sake/file-list"),
    log         = require("sake/logger"),
    defProp     = Object.defineProperty,
    defProps    = Object.defineProperties,
    isArray     = Array.isArray,
    DEFAULT_NAMESPACE = "default",
    CURRENT_NAMESPACE,
    // TBD
    FileTask,
    Task
;
//---------------------------------------------------------------------------
// Publics/Exports
//---------------------------------------------------------------------------
module.exports = Task = Proteus.Class.derive({
    //-----------------------------------------------------------------------
    // Static/Class Properties
    //-----------------------------------------------------------------------
    self: {
        
        tasks: {},
        
        initialize: function (obj, args) {
            var task = this.lookup(args[0], this.namespace);
            
            if (task) {
                task.enhance(args[1], args[2]);
                this.emit("updated", task);
            }

            return task;
        },
        
        /**
         * 1. task exists in current namespace
         * 2. task exists in default namespace
         * 3. task can be synthesized from a file
         */
        get: function (name, namespace) {
            var task, i;
            
            if (!FileTask) {
                FileTask = require("sake/file-task");
            }
            
            task = this.lookup(name, namespace) ||
                    this.lookup(name, DEFAULT_NAMESPACE) ||
                    FileTask.synthesize(name);
            
            if (!task) {
                if (!namespace && name && ~(i = name.indexOf(":"))) {
                    namespace = name.slice(0, i);
                    name = name.slice(i+1);
                }
                else if (!namespace) {
                    namespace = Task.namespace;
                }
                throw new Error("No task '" + name + "' in namespace '" + namespace + "'");
            }
            
            return task;
        },
        
        getAll: function () {
            var tasks = this.tasks;
            return Object.keys(tasks).map(function (key) {
                return tasks[key];
            });
        },
        
        lookup: function (name, namespace) {
            var i;
            
            if (name instanceof this) {
                return name;
            }
            else if (typeof name === "function") {
                return this.lookup(name(), namespace);
            }
            
            if (name && ~(i = name.indexOf(":"))) {
                namespace = name.slice(0, i);
                name = name.slice(i+1);
            }
            
            namespace = namespace || Task.namespace;
            
            return this.tasks[namespace + ":" + name];
        },
        
        has: function (name) {
            return Boolean(this.lookup(name));
        },
        
        find: function (args, sortFn) {
            var tasks = this.tasks,
                found;

            found = Object.keys(tasks).reduce(function (t, c) {
                var task = tasks[c];
                if (task.matches(args)) {
                    t.push(task);
                }
                return t;
            }, []);
            
            if (sortFn) {
                found.sort(sortFn);
            }
            
            return found;
        },
        
        destroy: function (name) {
            delete this.tasks[name];
        },
        
        invoke: function (name) {
            var task = this.get(name),
                args = Proteus.slice(arguments, 1)
            ;
            
            this.emit("invoking", task);
            task.invoke.apply(task, args);
            
            return task;
        },
        
        get namespace () {
            return CURRENT_NAMESPACE || DEFAULT_NAMESPACE;
        },
        
        set namespace (name) {
            CURRENT_NAMESPACE = name;
        }
    },
    //-----------------------------------------------------------------------
    // Instance Properties
    //-----------------------------------------------------------------------
    init: function (name, prereqs, action) {
        var i, namespace;
        
        if (~(i = name.indexOf(":"))) {
            namespace = name.slice(0, i);
            name = name.slice(i+1);
        }
        
        if (typeof prereqs === "function") {
            action = prereqs;
            prereqs = null;
        }
        
        this.name           = name;
        this.description    = "";
        this.namespace      = namespace || Task.namespace;
        this.actions        = [];

        defProps(this, {
            __pending__: {
                value: true,
                writable: true
            },
            __pendingPrereqs__: {
                value: []
            },
            __prerequisites__: {
                value: []
            },
            prerequisites: {
                get: function () {
                    this.resolve();
                    return this.__prerequisites__;
                },
                enumerable: true
            }
        });
        
        Task.tasks[this.namespace + ":" + this.name] = this;
        
        this.enhance(prereqs, action);
        
        this.enable();
    },
    
    type: "task",
    
    enhance: function (prereqs, action) {
        var isArr = isArray(prereqs),
            isFL  = prereqs instanceof FileList,
            isUndef = typeof prereqs === "undefined" || prereqs === null
        ;
        
        if (!isUndef) {
            if (!isArr && !isFL) {
                throw new Error("Prerequisites must be an Array or a FileList");
            }

            prereqs = isFL ? [prereqs] : prereqs;

            this.addPrerequisite.apply(this, prereqs);
        }
        
        if (action) {
            this.addAction(action);
        }
        
        this.emit("enhanced", this);
        
        return this;
    },
    
    invoke: function () {
        var alreadyRun  = this.alreadyRun,
            isNeeded    = this.isNeeded
        ;
        
        if (alreadyRun || !isNeeded) {
            if (alreadyRun) {
                log.debug("Already ran " + this.fqn + ".");
            }
            else if (!isNeeded) {
                log.debug("Not needed " + this.fqn + ".");
            }
            
            this.complete();
        }
        else {
            log.debug("Invoking " + this.fqn);
            this.arguments = Proteus.slice(arguments);
            require("sake/task-runner").run(this, this.complete.bind(this));
        }

        return this;
    },
    
    execute: function () {
        this.enable();
        log.debug("Executing " + this.fqn);
        this.arguments = Proteus.slice(arguments);
        require("sake/task-runner").run(this, this.complete.bind(this));
        return this;
    },
    
    enable: function () {
        this.enabled = !(this.alreadyRun = false);
        this.emit("enabled", this);
        return this;
    },
    
    done: function () {
        this.emit("actionDone", this);
        return this;
    },
    
    complete: function () {
        this.enabled = !(this.alreadyRun = true);
        log.debug("Task complete " + this.fqn + ".");
        this.emit("complete", this);
        return this;
    },
    
    abort: function (msg, exitCode) {
        var message = "Aborting " + this.fqn + ": " + msg;
        
        if (typeof exitCode !== "undefined") {
            log.error(message);
            process.exit(exitCode);
        }
        else {
            log.info(message);
        }
        this.emit("abort", msg || true, this);
        return this;
    },
    
    resolve: (function () {
        function addPending (prereqs, preq) {
            // make sure the prerequisite exists as a task
            Task.get(preq, this.namespace);
            if (!~prereqs.indexOf(preq)) {
                prereqs.push(preq);
            }
        }
        
        return function () {
            var fn = addPending.bind(this, this.__prerequisites__),
                nil
            ;
            
            if (this.__pending__) {
                this.__pendingPrereqs__.forEach(function (preq) {
                    nil = preq instanceof FileList || isArray(preq) ?
                        preq.forEach(fn) :
                        fn(preq);
                });
                this.__pendingPrereqs__.length = 0;
                this.__pending__ = false;
            }
        };
    }()),
    
    addPrerequisite: function () {
        Proteus.slice(arguments).forEach(function (preq) {
            this.push(preq);
        }, this.__pendingPrereqs__);
        this.__pending__ = true;
        return this;
    },
    
    addPrerequisites: Proteus.aliasMethod("addPrerequisite"),
    
    addAction: function () {
        Proteus.slice(arguments).forEach(function (fn) {
            if (typeof fn !== "function") {
                throw new Error("Task action must be a function.");
            }
            this.push(fn);
        }, this.actions);
        return this;
    },
    
    addActions: Proteus.aliasMethod("addAction"),
    
    destroy: function () {
        Task.destroy(this.name);
    },

    matches: function (args) {
        var key;
        
        if (typeof args === "function") {
            return args(this);
        }
        
        for (key in args) {
            if (this[key] !== args[key]) {
                return false;
            }
        }
        
        return true;
    },
    
    inspect: function () {
        return [
            Array(72).join("-"),
            "task: "            + this.name, 
            "namespace: "       + this.namespace,
            "type: "            + this.type,
            "description: "     + this.description,
            "prerequisites: "   + this.prerequisites.join(", "),
            "isNeeded: "        + this.isNeeded,
            "alreadyRun: "      + this.alreadyRun,
            "timestamp: "       + this.timestamp
        ].join("\n");
    },
    
    toString: function () {
        return this.inspect();
    },
    
    isNeeded: true,
    
    get fqn () {
        var ns = this.namespace,
            name = this.name
        ;
        
        return (ns !== DEFAULT_NAMESPACE ? ns + ":" : "") + this.name;
    },
    
    get timestamp () {
        var max = Math.max.apply(
                Math,
                this.prerequisites.map(function (p) {
                    return p.timestamp;
                })
            );
        
        return isFinite(max) ? max : Date.now();
    }
    
});

// Give the Task class event emitter functionality
Proteus.extend(Task, EM.prototype);
// And the same for the instances of Task
Task.include(EM);
