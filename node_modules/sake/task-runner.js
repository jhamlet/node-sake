
var Proteus = require("proteus"),
    async   = require("async"),
    Task    = require("sake/task"),
    options = require("sake/options"),
    log     = require("sake/logger"),
    Runner,
    ActionRunner,
    TaskRunner
;

/**
 * Base class for Task and Actions runners
 */
Runner = Proteus.Class.derive({
    init: function (callback) {
        this.callback = callback;
    },
    
    complete: function (err) {
        var nil = this.callback && this.callback(err);
        this.destroy();
    },
    
    destroy: function () {
        delete this.callback;
    }
});

/**
 * Responsible for running a tasks actions, one by one.
 */
ActionRunner = Runner.derive({
    
    init: function (task, callback) {
        this.task = task;
        ActionRunner.__super__.init.call(this, callback);
    },
    
    run: function () {
        var self        = this,
            task        = this.task,
            actions     = task.actions,
            taskArgs    = [task].concat(task.arguments),
            noActions   = !actions || !actions.length,
            callback    = this.complete.bind(this),
            dryrun      = options.dryrun,
            drySuffix   = dryrun ? " (dry-run)" : ""
        ;
        
        if (noActions) {
            log.debug("No actions for " + task.fqn);
            callback();
            return;
        }
        
        async.series(actions.map(function (action, idx) {
            return function (asyncCb) {
                function actionCb (abort, t) {
                    abort = abort === task ? false : abort;

                    if (action.doneCb !== actionCb) {
                        log.debug(task.fqn + " action callback called out of context.");
                        return;
                    }
                    
                    delete action.doneCb;
                    
                    task.removeListener("actionDone", actionCb);
                    task.removeListener("abort", actionCb);

                    log.debug(
                        task.fqn + " action " + idx +
                        (abort ? " aborted." : " complete" + drySuffix + ".")
                    );

                    asyncCb(abort);
                }
                
                action.doneCb = actionCb;
                
                task.on("actionDone", actionCb);
                task.on("abort", actionCb);

                log.debug("Execute " + task.fqn + " action " + idx + drySuffix);

                async.nextTick(function () {
                    if (dryrun) {
                        actionCb();
                    }
                    else {
                        action.apply(this, taskArgs);
                    }
                });
            };
        }), callback);
    },
    
    destroy: function () {
        delete this.task;
        ActionRunner.__super__.destroy.call(this);
    },
    
});

/**
 * Responsible for executing a task's prerequisites one by one
 */
TaskRunner = Runner.derive({
    
    init: function (task, callback) {
        this.task = task;
        TaskRunner.__super__.init.call(this, callback);
    },
    
    run: function () {
        var self        = this,
            task        = this.task,
            running     = task.isRunning,
            prereqs     = task.prerequisites,
            hasPreqs    = prereqs && prereqs.length,
            callback    = this.postRun.bind(this)
        ;
        
        if (running) {
            log.warn(
                "Possible dependency recursion: " + task.fqn +
                " is already running."
            );
            return;
        }
        
        if (!hasPreqs) {
            log.debug("No prerequisites for " + task.fqn);
            return callback();
        }
        
        task.isRunning = true;
        async.series(prereqs.map(function (taskname) {
            var t = Task.get(taskname, task.namespace);
            
            return function (asyncCb) {
                function taskCb () {
                    delete t.isRunning;
                    asyncCb();
                }
                
                t.once("complete", taskCb);
                async.nextTick(function () { t.invoke(); });
            };
        }), callback);
    },
    
    postRun: function () {
        var task     = this.task,
            callback = this.complete.bind(this)
        ;
        
        if (task.isNeeded && !task.alreadyRun) {
            (this.actionRunner = new ActionRunner(this.task, callback)).run();
        }
        else {
            callback();
        }
    },
    
    destroy: function () {
        delete this.task;
        delete this.actionRunner;
        TaskRunner.__super__.destroy.call(this);
    }
    
});

module.exports = {
    run: function (task, callback) {
        (new TaskRunner(task, callback)).run();
    }
};
