
var Proteus         = require("proteus"),
    resolve         = require("resolve"),
    VM              = require("vm"),
    FS              = require("fs"),
    Path            = require("path"),
    nutil           = require("util"),
    sutil           = require('sake/util'),
    Glob            = require("glob"),
    sutil           = require("sake/util"),
    log             = require("sake/logger"),
    nodeRequire     = require,
    nodePath        = process.env.NODE_PATH,
    nodePaths       = nodePath ? nodePath.split(":") : [],
    existsSync      = FS.existsSync || Path.existsSync,
    TASK_DESCRIPTION = "",
    sake            = {},
    OPTIONS         = {},
    NAMESPACES      = [],
    PATH_SPLIT_RE   = process.platform === "win32" ? /[\/\\]+/ : /\/+/,
    CURRENT_PATH,
    sakeContext,
    futil,
    Task,
    FileTask,
    FileList,
    FileCreateTask
;

//---------------------------------------------------------------------------
// Utilities for resolving requires
//---------------------------------------------------------------------------
CURRENT_PATH = process.cwd();

function sakeRequire (name) {
    var opts, paths, i, modpath;
    
    try {
        return nodeRequire(name);
    }
    catch (e) {
        opts = { paths: nodePaths };
        paths = [
            __dirname,
            process.cwd(),
            sutil.directoryFromStackTrace(__filename)
        ];
        i = paths.length;
        while (i-- && !modpath) {
            if (paths[i]) {
                opts.basedir = paths[i];

                try {
                    modpath = resolve.sync(name, opts);
                }
                catch (err) {
                    // do nothing
                }
            }
        }
        
        if (!modpath) {
            throw new Error('Can not find module \'' + name + '\'');
        }
        
        return nodeRequire(modpath);
    }
}
//---------------------------------------------------------------------------
// Create the Run Context
//---------------------------------------------------------------------------
function getRunContext () {
    if (!sakeContext) {
        sakeContext = VM.createContext(
            Proteus.merge(
                {
                    console:        console,
                    process:        process,
                    
                    Buffer:         Buffer,
                    setTimeout:     setTimeout,
                    setInterval:    setInterval,
                    clearTimeout:   clearTimeout,
                    clearInterval:  clearInterval
                },
                sake,
                futil
            )
        );
    }
    
    return sakeContext;
}
//---------------------------------------------------------------------------
// Privates
//---------------------------------------------------------------------------
function defineTask (TaskClass, sync, name, prereqs, action) {
    var task, fn;
    
    if (!action && typeof prereqs === "function") {
        action = prereqs;
        prereqs = null;
    }
    
    if (action) {
        if (!sync &&
            (action.length < 1 || !(/\.(?:done|abort)(?:\.bind)?\(/.test(action.toString())))
        ) {
            log.warn(
                "Possibly missing task done call in asynchronous action " +
                "added to task '" + name + "'"
            );
        }
        
        fn = !sync ? action : function (t) {
                var v = action.apply(this, arguments);
                t.done();
            };
    }
    
    if (!(task = Task.lookup(name))) {
        log.debug("defining task: " + name);
        task = new TaskClass(name, prereqs, fn);
        task.description = TASK_DESCRIPTION;
    }
    else {
        log.debug("enhancing task: " + name);
        task.enhance(prereqs, fn);
    }
    
    TASK_DESCRIPTION = "";

    return task;
}

function createTask (TaskClass, name, prereqs, action) {
    return defineTask(
        TaskClass,
        sake.options.sync,
        name,
        prereqs,
        action
    );
}
//---------------------------------------------------------------------------
// Public/Exports
//---------------------------------------------------------------------------
Proteus.merge(sake, Object.defineProperties({
    
    run: function (filepath) {
        var code, ret;
        
        log.debug("sake#run");
        
        if (typeof filepath === "function") {
            code = "(" + filepath.toString() + "())";
            filepath = "anonymous function";
        }
        else {
            filepath = Path.resolve(
                sutil.directoryFromStackTrace(__filename),
                filepath
            );
            log.debug("Reading Sakefile: " + filepath);
            code = FS.readFileSync(filepath, "utf8");
            
            if (Path.extname(filepath).toLowerCase() === ".coffee") {
                try {
                    code = require("coffee-script").compile(code);
                }
                catch (e) {
                    log.error("Coffee script is not installed.\n");
                    process.exit(1);
                }
            }
        }
        
        return VM.runInContext(code, getRunContext(), filepath);
    },
    
    // load:    Proteus.aliasMethod("run", sake),
    load: function () {
        log.debug("sake#load");
        return sake.run.apply(sake, arguments);
    },
    
    include: function () {
        log.debug("sake#include");
        return sake.run.apply(sake, arguments);
    },
    
    require: sakeRequire,
    
    log: require("sake/logger"),
    
    description: function (txt) {
        TASK_DESCRIPTION += txt;
    },
    desc: Proteus.aliasMethod("description", sake),
    
    directory: (function () {
        
        function mkdirAction (t) {
            if (!existsSync(t.name)) {
                futil.mkdir_p(t.name);
            }
        }

        return function (name) {
            var dirpath = name;

            while (dirpath !== "." && dirpath !== "/") {
                sake.fileCreateSync(dirpath, mkdirAction);
                dirpath = Path.dirname(dirpath);
            }

            return Task.get(name);
        };
    }()),
    
    namespace: function (name, fn) {
        var prev = Task.namespace;
        
        if (!arguments.length) {
            return prev;
        }
        
        Task.namespace = name;
        
        fn();
        
        Task.namespace = prev;
    },
    
    sake: sake,
    
    async: require("async")
}, {
    __dirname: { 
        get: function () {
            return sutil.directoryFromStackTrace(__filename);
        },
        enumerable: true
    },
    
    __filename: {
        get: function () {
            return sutil.fileFromStackTrace(__filename);
        },
        enumerable: true
    }
}));

//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
/**
 * Define the exports as a 'getter', and then re-define it as a plain property
 * once everything is all setup and ready to go.
 */
Object.defineProperty(module, "exports", {
    get: function () {
        var opts = (sake.options = require("sake/options"));

        opts.requires.forEach(function (name) {
            var property = sutil.toCamelCase(Path.basename(name, ".js"));
            if (!sake.hasOwnProperty(property)) {
                sake[property] = sakeRequire(name);
            }
            else {
                throw new Error(
                    "Namespace conflict. Can not require '" + name + "'" +
                    "as it will conflict with a property that is " +
                    "already defined."
                );
            }
        });
        
        // Re-define our exported property
        Object.defineProperty(module, "exports", {
            value: sake,
            enumerable: true
        });
        
        // Require these here to avoid recursive requires
        futil                                   = require("sake/file-utils");
        sake.Task           = Task              = require("sake/task");
        sake.FileTask       = FileTask          = require("sake/file-task");
        sake.FileCreateTask = FileCreateTask    = require("sake/file-create-task");
        sake.FileList       = FileList          = require("sake/file-list");
        
        // bind our task creation functions
        sake.task               = createTask.bind(sake, Task);
        sake.taskAsync          = defineTask.bind(sake, Task, false);
        sake.taskSync           = defineTask.bind(sake, Task, true);
                                
        sake.file               = createTask.bind(sake, FileTask);
        sake.fileAsync          = defineTask.bind(sake, FileTask, false);
        sake.fileSync           = defineTask.bind(sake, FileTask, true);
        
        sake.fileCreate         = createTask.bind(sake, FileCreateTask);
        sake.fileCreateAsync    = defineTask.bind(sake, FileCreateTask, false);
        sake.fileCreateSync     = defineTask.bind(sake, FileCreateTask, true);
        
        // load sakelib files
        opts.sakelib.filter(function (dirpath, idx) {
            return existsSync(dirpath) &&
                    FS.statSync(dirpath).isDirectory();
        }).reduce(function (paths, dirpath) {
            var glob = Path.join(dirpath, "*.{sake,sake.js,sake.coffee}");
            return paths.concat(Glob.sync(glob));
        }, []).forEach(sake.load, sake);
        
        // return our object
        return sake;
    },
    enumerable: true,
    configurable: true
});

