
var Proteus         = require("proteus"),
    resolve         = require("resolve"),
    VM              = require("vm"),
    FS              = require("fs"),
    Path            = require("path"),
    nutil           = require("util"),
    Glob            = require("glob"),
    sutil           = require("sake/util"),
    log             = require("sake/logger"),
    nodeRequire     = require,
    nodePath        = process.env.NODE_PATH,
    nodePaths       = nodePath ? nodePath.split(":") : [],
    existsSync      = FS.existsSync || Path.existsSync,
    TASK_DESCRIPTION = "",
    sake            = {},
    OPTIONS         = {},
    INCLUDE_PATHS   = [],
    NAMESPACES      = [],
    PATH_SPLIT_RE   = process.platform === "win32" ? /[\/\\]+/ : /\/+/,
    CURRENT_PATH,
    sakeContext,
    futil,
    Task,
    FileTask,
    FileList,
    FileCreateTask
;

//---------------------------------------------------------------------------
// Utilities for resolving requires
//---------------------------------------------------------------------------
INCLUDE_PATHS.push(__dirname, process.cwd());
CURRENT_PATH = INCLUDE_PATHS[INCLUDE_PATHS.length-1];
/**
 * Turn a path into an array of node_module search paths.
 */
function explodePath (dirs, path) {
    var nm      = "node_modules",
        parts   = path.split(PATH_SPLIT_RE),
        nmIdx   = parts.indexOf(nm),
        rootIdx = ~nmIdx ? nmIdx : 0,
        rootRel = parts[0] === "",
        i       = parts.length - 1,
        part,
        dir
    ;
    
    dirs = dirs || [];
    
    while (i >= rootIdx) {
        part = parts[i];
        dir = parts.slice(0, i+1);
        if (part !== nm) {
            dir.push(nm);
        }
        dirs.push((rootRel ? "/" : "") + Path.join.apply(Path, dir));
        i--;
    }
    
    return dirs;
}

function sakeRequire (name) {
    var opts;
    
    try {
        return nodeRequire(name);
    }
    catch (e) {
        opts = {
            basedir: Path.dirname(CURRENT_PATH),
            paths: INCLUDE_PATHS.reduce(explodePath, []).concat(nodePaths)
        };
        return nodeRequire(resolve.sync(name, opts));
    }
}
//---------------------------------------------------------------------------
// Create the Run Context
//---------------------------------------------------------------------------
function getRunContext () {
    if (!sakeContext) {
        sakeContext = VM.createContext(
            Proteus.merge(
                {
                    console:        console,
                    process:        process,
                    
                    Buffer:         Buffer,
                    setTimeout:     setTimeout,
                    setInterval:    setInterval,
                    clearTimeout:   clearTimeout,
                    clearInterval:  clearInterval
                },
                sake,
                futil
            )
        );
    }
    
    return sakeContext;
}
//---------------------------------------------------------------------------
// Privates
//---------------------------------------------------------------------------
function defineTask (TaskClass, sync, name, prereqs, action) {
    var task, fn;
    
    if (!action && typeof prereqs === "function") {
        action = prereqs;
        prereqs = null;
    }
    
    if (action) {
        if (!sync &&
            (action.length < 1 || !(/\.(?:done|abort)(?:\.bind)?\(/.test(action.toString())))
        ) {
            log.warn(
                "Possibly missing task done call in asynchronous action " +
                "added to task '" + name + "'"
            );
        }
        
        fn = !sync ? action : function (t) {
                var v = action.apply(this, arguments);
                t.done();
            };
    }
    
    if (!(task = Task.lookup(name))) {
        log.debug("defining task: " + name);
        task = new TaskClass(name, prereqs, fn);
        task.description = TASK_DESCRIPTION;
    }
    else {
        log.debug("enhancing task: " + name);
        task.enhance(prereqs, fn);
    }
    
    TASK_DESCRIPTION = "";

    return task;
}

function createTask (TaskClass, name, prereqs, action) {
    return defineTask(
        TaskClass,
        sake.options.sync,
        name,
        prereqs,
        action
    );
}
//---------------------------------------------------------------------------
// Public/Exports
//---------------------------------------------------------------------------
Proteus.merge(sake, Object.defineProperties({
    
    run: function (filepath) {
        var tmpPath = CURRENT_PATH,
            isFn, code, ret
        ;
        
        log.debug("sake#run");
        
        if (typeof filepath === "function") {
            isFn = true;
            code = "(" + filepath.toString() + "())";
            filepath = "anonymous function";
        }
        else {
            filepath = Path.resolve(sake.__dirname, filepath);
            CURRENT_PATH = filepath;

            log.debug("Reading Sakefile: " + filepath);
            code = FS.readFileSync(filepath, "utf8");
            
            if (Path.extname(filepath).toLowerCase() === ".coffee") {
                try {
                    code = require("coffee-script").compile(code);
                }
                catch (e) {
                    log.error("Coffee script is not installed.\n");
                    process.exit(1);
                }
            }
        }
        
        try {
            ret = VM.runInContext(code, getRunContext(), filepath);
        }
        catch (runErr) {
            // TODO: Define a Sake specific error
            process.stderr.write(
                filepath + ": " +  runErr.toString() + runErr.stack + "\n"
            );
            process.exit(1);
        }
        
        if (!isFn) {
            CURRENT_PATH = tmpPath;
        }
        
        return ret;
    },
    
    // load:    Proteus.aliasMethod("run", sake),
    load: function () {
        log.debug("sake#load");
        return sake.run.apply(sake, arguments);
    },
    include: Proteus.aliasMethod("run", sake),
    
    require: sakeRequire,
    
    log: require("sake/logger"),
    
    description: function (txt) {
        TASK_DESCRIPTION += txt;
    },
    desc: Proteus.aliasMethod("description", sake),
    
    directory: (function () {
        
        function mkdirAction (t) {
            if (!existsSync(t.name)) {
                futil.mkdir_p(t.name);
            }
        }

        return function (name) {
            var dirpath = name;

            while (dirpath !== "." && dirpath !== "/") {
                sake.fileCreateSync(dirpath, mkdirAction);
                dirpath = Path.dirname(dirpath);
            }

            return Task.get(name);
        };
    }()),
    
    namespace: function (name, fn) {
        var prev = Task.namespace;
        
        if (!arguments.length) {
            return prev;
        }
        
        Task.namespace = name;
        
        fn();
        
        Task.namespace = prev;
    },
    
    includePaths: INCLUDE_PATHS,
    
    sake: sake,
    
    async: require("async")
}, {
    __dirname: {
        get: function () {
            return Path.dirname(CURRENT_PATH);
        },
        enumerable: true
    },
    
    __filename: {
        get: function () {
            return CURRENT_PATH;
        },
        enumerable: true
    }
}));

//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
/**
 * Define the exports as a 'getter', and then re-define it as a plain property
 * once everything is all setup and ready to go.
 */
Object.defineProperty(module, "exports", {
    get: function () {
        var opts = (sake.options = require("sake/options"));

        opts.requires.forEach(function (name) {
            var property = sutil.toCamelCase(Path.basename(name, ".js"));
            if (!sake.hasOwnProperty(property)) {
                sake[property] = sakeRequire(name);
            }
            else {
                throw new Error(
                    "Namespace conflict. Can not require '" + name + "'" +
                    "as it will conflict with a property that is " +
                    "already defined."
                );
            }
        });
        
        // Re-define our exported property
        Object.defineProperty(module, "exports", {
            value: sake,
            enumerable: true
        });
        
        // Require these here to avoid recursive requires
        futil                                   = require("sake/file-utils");
        sake.Task           = Task              = require("sake/task");
        sake.FileTask       = FileTask          = require("sake/file-task");
        sake.FileCreateTask = FileCreateTask    = require("sake/file-create-task");
        sake.FileList       = FileList          = require("sake/file-list");
        
        // bind our task creation functions
        sake.task       = createTask.bind(sake, Task);
        sake.taskAsync  = defineTask.bind(sake, Task, false);
        sake.taskSync   = defineTask.bind(sake, Task, true);
        
        sake.file       = createTask.bind(sake, FileTask);
        sake.fileAsync  = defineTask.bind(sake, FileTask, false);
        sake.fileSync   = defineTask.bind(sake, FileTask, true);
        
        sake.fileCreate         = createTask.bind(sake, FileCreateTask);
        sake.fileCreateAsync    = defineTask.bind(sake, FileCreateTask, false);
        sake.fileCreateSync     = defineTask.bind(sake, FileCreateTask, true);
        
        // load sakelib files
        opts.sakelib.filter(function (dirpath, idx) {
            return existsSync(dirpath) &&
                    FS.statSync(dirpath).isDirectory();
        }).reduce(function (paths, dirpath) {
            var glob = Path.join(dirpath, "*.{sake,sake.js,sake.coffee}");
            return paths.concat(Glob.sync(glob));
        }, []).forEach(sake.load, sake);
        
        // return our object
        return sake;
    },
    enumerable: true,
    configurable: true
});

